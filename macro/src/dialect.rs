mod error;
mod generation;
mod input;
mod operation;
mod r#trait;
mod r#type;
mod utility;

use self::{
    error::Error,
    generation::generate_operation,
    utility::{sanitize_documentation, sanitize_snake_case_identifier},
};
use convert_case::{Case, Casing};
pub use input::DialectInput;
use operation::Operation;
use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use std::{
    env,
    fmt::Display,
    path::{Component, Path},
    str,
};
use tblgen::{TableGenParser, record::Record, record_keeper::RecordKeeper};

const LLVM_INCLUDE_DIRECTORY: &str = env!("LLVM_INCLUDE_DIRECTORY");

pub fn generate_dialect(input: DialectInput) -> Result<TokenStream, Box<dyn std::error::Error>> {
    let mut parser = TableGenParser::new();

    parser = parser.add_include_directory(LLVM_INCLUDE_DIRECTORY);

    for path in input.directories() {
        let path = if matches!(
            Path::new(path).components().next(),
            Some(Component::CurDir | Component::ParentDir)
        ) {
            path.into()
        } else {
            Path::new(LLVM_INCLUDE_DIRECTORY).join(path)
        };

        parser = parser.add_include_directory(&path.display().to_string());
    }

    if input.files().count() > 0 {
        parser = parser.add_source(&input.files().fold(String::new(), |source, path| {
            source + "include \"" + path + "\""
        }))?;
    }

    let keeper = parser.parse().map_err(Error::Parse)?;

    let dialect = generate_dialect_module(
        input.name(),
        keeper
            .all_derived_definitions("Dialect")
            .find(|definition| definition.str_value("name") == Ok(input.name()))
            .ok_or_else(|| create_syn_error("dialect not found"))?,
        &keeper,
    )
    .map_err(|error| error.add_source_info(keeper.source_info()))?;

    Ok(quote! { #dialect }.into())
}

fn generate_operation_enum(
    dialect_name: &str,
    record_keeper: &RecordKeeper,
) -> Result<Option<proc_macro2::TokenStream>, Error> {
    let enum_name = quote::format_ident!("{}Operation", dialect_name.to_case(Case::Pascal));

    let mut operations = record_keeper
        .all_derived_definitions("Op")
        .map(Operation::new)
        .collect::<Result<Vec<_>, _>>()?;
    operations.retain(|operation| operation.dialect_name() == dialect_name);

    let enum_ident = quote::format_ident!("{}Operation", dialect_name.to_case(Case::Pascal));

    let match_arms = operations.iter().map(|operation| {
        let ident = quote::format_ident!("{}", operation.name());
        let full_name = operation.full_operation_name();

        quote! {
            #full_name => Ok(#enum_name::#ident(#ident::try_from(operation.clone()).expect("operation should match type"))),
        }
    }).collect::<Vec<_>>();

    let raw_match_arms = operations
        .iter()
        .map(|operation| {
            let ident = quote::format_ident!("{}", operation.name());

            quote! {
                #enum_ident::#ident(op) => op.as_operation(),
            }
        })
        .collect::<Vec<_>>();

    let clone_match_arms = operations
        .iter()
        .map(|operation| {
            let ident = quote::format_ident!("{}", operation.name());

            quote! {
                #enum_ident::#ident(op) => #enum_ident::#ident(#ident { operation: op.as_operation().clone() }),
            }
        })
        .collect::<Vec<_>>();

    let operation_enum = operations
        .iter()
        .map(|operation| quote::format_ident!("{}", operation.name()))
        .map(|operation| {
            quote! {
                #operation(#operation<'b>)
            }
        })
        .collect::<Vec<_>>();

    let from_impls = operations.iter().map(|operation| {
        let ident = quote::format_ident!("{}", operation.name());

        quote! {
            impl<'b> From<#ident<'b>> for #enum_ident<'b> {
                fn from(op: #ident<'b>) -> Self {
                    #enum_ident::#ident(op)
                }
            }
        }
    });

    if operation_enum.is_empty() {
        Ok(None)
    } else {
        let enum_definition = quote! {
            pub enum #enum_name<'b> {
                #(#operation_enum),*
            }

            impl<'b> Clone for #enum_name<'b> {
                fn clone(&self) -> Self {
                    match self {
                        #(#clone_match_arms)*
                    }
                }
            }

            impl<'b> std::fmt::Display for #enum_name<'b> {
                fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                   std::fmt::Display::fmt(self.as_operation(), formatter)
                }
            }

            impl<'b> #enum_name<'b> {
                pub fn try_new(operation: melior::ir::operation::Operation<'b>) -> Result<Self, melior::ir::operation::Operation<'b>> {
                    match operation.name().as_string_ref().as_str().unwrap() {
                        #(#match_arms)*
                        _ => Err(operation),
                    }
                }
            }

            impl<'b> #enum_name<'b> {
                pub fn as_operation(&self) -> &melior::ir::operation::Operation<'b> {
                    match self {
                        #(#raw_match_arms)*
                    }
                }
            }

            #(#from_impls)*
        };
        Ok(Some(enum_definition))
    }
}

fn generate_dialect_module(
    name: &str,
    dialect: Record,
    record_keeper: &RecordKeeper,
) -> Result<proc_macro2::TokenStream, Error> {
    let dialect_name = dialect.name()?;
    let operations = record_keeper
        .all_derived_definitions("Op")
        .map(Operation::new)
        .collect::<Result<Vec<_>, _>>()?
        .iter()
        .filter(|operation| operation.dialect_name() == dialect_name)
        .map(generate_operation)
        .collect::<Vec<_>>();

    let doc = format!(
        "`{name}` dialect.\n\n{}",
        sanitize_documentation(dialect.str_value("description").unwrap_or(""),)?
    );
    let name = sanitize_snake_case_identifier(name)?;
    let enum_definition = generate_operation_enum(dialect_name, record_keeper)?;

    Ok(quote! {
        #[doc = #doc]
        pub mod #name {
            use melior::ir::operation::OperationLike;
            use melior::ir::operation::OperationMutLike;

            #(#operations)*

            #enum_definition
        }
    })
}

fn create_syn_error(error: impl Display) -> syn::Error {
    syn::Error::new(Span::call_site(), format!("{error}"))
}
